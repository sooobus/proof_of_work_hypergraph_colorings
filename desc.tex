\documentclass{article}
	% General document formatting
	\usepackage[margin=0.7in]{geometry}
	\usepackage[parfill]{parskip}
	\usepackage[utf8]{inputenc}    
	%\usepackage{mathtext}
	%\usepackage[T1,T2A]{fontenc}
	\usepackage[english,russian]{babel}

	% Related to math
	\usepackage{amsmath,amssymb,amsfonts,amsthm}

	\title{Пример применимой для Proof-Of-Work функции и тестирование её применимости}
	\date{26 ноября 2017}
	\author{Валерия Немычникова, 599 группа ФИВТ МФТИ}
    \newtheorem*{theorem}{Теорема}
\begin{document}
\maketitle


\section{Введение}

    Proof-of-Work (POW) -- это принцип защиты распределённых систем от злоупотребления ими, таких, как рассылка спама. Также POW используется в некоторых блокчейн-системах, например, в Bitcoin.

    Основная идея POW в том, что рассматривается некая функция, которая в одну сторону вычисляется быстро, а в другую \textit{умеренно} сложно. Под умеренностью подразумевается (это будет формализовано позже) то, что функцию вычислить можно за разумное, но достаточно большое время. Например, если проезд по платной дороге стоит какое-то количество денег, то заработать эти деньги занимает разумное время, а проверка факта оплаты мгновенная.

    В этой работе будет рассмотрен пример "хорошей" для POW функции, устроенной на основе поиска системы общих представителей данного семейства множеств, которая, по информации автора, раньше не упоминалась в статьях по этой теме. Будет приведено доказательство того, что функция удовлетворяет требуемым свойствам и приведены расчёты, показывающие её практическую применимость. В качестве демонстрации также будет приведён код простого блокчейна, который в качестве POW использует эту функцию.

    Далее работа устроена следующим образом. Вначале будут даны необходимые определения. Далее будет доказано, что функция на основе с.о.п. удовлетворяет требованиям, необходимым для POW. После этого будут приведены расчёты подходящих параметров для практического использования этой функции. Наконец, будет приведено описание простейшего блокчейна, использующего вычисление системы общих представителей в качестве доказательства работы.
\section{Определения}

Функция $f$ называется \textit{pricing-функцией}, если выполнены следующие условия:
\begin{enumerate}
\item $f$ умеренно сложно вычислить;
\item $f$ не поддаётся амортизации: если даны $l$ значений $m_1, ..., m_l$, то амортизированная стоимость вычисления $f(i) \forall i: 1 \leq i \leq l$ сравнима со стоимостью вычисления $f(m_i)$.
\item Если даны $x, y$, то легко вычислить, что $y = f(x)$.

\end{enumerate}

Здесь под умеренной сложностью вычисления имеется в виду, что выполнение этой функции занимает существенное время по сравнению с проверкой ответа.

Пусть дано множество $A$ и семейство его подмножеств $\mathcal{M}$. \textit{Системой общих представителей} этого семейства называется такое $B \subset A$, что $\forall C \in \mathcal{M} \exists b \in B | b \in C$. 

\textit{Минимальной системой общих представителей} семейства подмножеств назовём систему общих представителей этого семейства минимального размера.

\section{Пример pricing-функции на основе систем общих представителей}

    Нахождение минимальной системы общих представителей -- задача, в общем случае требующая полного перебора. Известны "жадные" верхние оценки на размер системы общих представителей. 

    Рассмотрим множество $A$ из $n$ элементов. Зафиксируем $k$ -- количество элементов в его подмножестве. Рассмотрим семейства, состоящие из $s$ $k$-элементных подмножеств $A$. Зафиксируем какое-нибудь такое семейство.
    Обозначим за $\zeta(n, s, k)$ размер минимальной с.о.п. для этого семейства. С одной стороны, $$\zeta(n, s, k) \leq G(n, s, k) := \max\{\frac{n}{k}, \frac{n}{k} \ln \frac{sk}{n}\} + \frac{n}{k} + 1$$. С другой стороны, это общая оценка, которая получается жадным алгоритмом, и в частном случае эту оценку можно улучшить, непосредственно проделав шаги жадного алгоритма, причём это займёт меньше, чем $O(G(n, s, k)) = O(n \log k)$ шагов. Обозначим жадную оценку размера минимальной с.о.п. для данного семейства множеств за $Gr(\mathcal{M})$.

    Обозначим через $CR(\mathcal{M})$ любую систему общих представителей данного семейства множеств.

    Рассмотрим следующую функцию $F$. Определим $F$ только для такого семейства подмножеств $n$ -- элементного множества, что каждый элемент $n$-элементного множества встречается хотя бы в одном множестве семейства.

\begin{equation*}
    F_{n,s,k}(\mathcal{A}) = 
     \begin{cases}
       |CR(\mathcal{M})| \text{ такой что} (Gr(\mathcal{A}) > |CR(\mathcal{M})|), \text{ если существует такая } CR(\mathcal{M}) \\
       -1 \text{ иначе}
    \end{cases}
\end{equation*}
    
    Неформально говоря, это такой размер с.о.п. для данного семейства множеств, который улучшает жадную оценку.


\begin{theorem}
    Пусть не существует полиномиального алгоритма для вычисления минимальной системы общих представителей произвольного семейства множеств. Тогда $F$ является pricing-функцией. 
\end{theorem}

Докажем это исходя непосредственно из определения.
\begin{enumerate}
\item $F$ можно вычислить полным перебором. Рассмотрим всевозможные подмножества элементов семейства, у которого ищем с.о.п. и для каждого такого подмножества проверим, что оно является с.о.п. Перебор займёт $O(2^{2^n})$. 
\item [TODO] $n$, $s$, $k$
\item Зная с.о.п. в явном виде, можно за $O(n^2 \log k)$ непосредственно проверить, что такое семейство множеств является с.о.п. за $O(n * p)$, где $p$ -- размер с.о.п. Это занимает полиномиальное время.
\end{enumerate}

\section{Подходящие параметры для $F$}

    Подберём параметры $n, k, s$ таким образом, чтобы перебор занимал значительное время. Будем отталкиваться от того, чтобы программа на С++ (который достаточно быстрый) работала 10 секунд. Так как основную часть работы программы будут составлять вычисления, можно считать, что программа на Python + numpy будет работать примерно столько же.
    Кроме времени работы ещё хочется, чтобы общее количество возможных вычислений было довольно велико. А именно, чтобы задавшись один раз тройкой параметров, можно было запустить такой блокчейн, которому хватит возможных входных данных на разумное время. Зададимся для примера одним блоком в 10 секунд. Тогда если считать, что блокчейн проработает 50 лет, ему понадобится порядка 200 миллионов различных семейств множеств для поиска в них с.о.п.
    Рассмотрим такой эксперимент. Рассмотрим несколько различных троек значений $n, k, s$. Сгенерируем семейство случайных $k$-элементных подмножеств $n$-элементного множества. Сначала жадно найдём с.о.п., получим жадную оценку. Потом станем искать с.о.п. полным перебором. Возможны 3 различных исхода: что сгенерированное семество вообще не будет иметь с.о.п. (иначе говоря, мы собираем школьников на олимпиаду по русскому языку, которая включает решение задач на синтаксис, морфологию и древнерусский язык, а никто из наших школьников не знает древнерусского), что полным перебором мы получим, что жадную оценку нельзя улучшить, или что жадная оценка улучшилась.
    Первый случай, очевидно, нам не подходит. Второй случай тоже плохой: в качестве доказательства, что $F$ вычислено, мы предъявим непосредственно сами множества. Но доказательство того, что мы перебрали все подмножества, будет слишком длинным. Поэтому будем считать такой случай тоже плохим.
    Цель эксперимента: найти такую тройку параметров, что почти всегда будет реализовываться третий случай: что жадная оценка улучшаема. И это действительно так. Запустив скрипт $timing.py$, мы нашли такие тройки (выделены в таблице), что при генерации случайных семейств подмножеств с такими параметрами часто получаются такие семейства, в которых интересно искать с.о.п, перебор занимает хорошее время (10-30 секунд), а разных семейств подмножеств достаточно много.
\section{Описание простейшего блокчейна, использующего $F$}

Описание появится здесь после написания программы.

\end{document}
